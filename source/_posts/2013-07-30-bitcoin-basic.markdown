---
layout: post
title: "比特币基础知识"
date: 2013-07-30 23:58
comments: true
categories: 
---


### 基本概念

#### 椭圆曲线数字签名算法

椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线对数字签名算法（DSA）的模拟，该算法是构成比特币系统的基石。

##### 私钥

非公开，拥有者需安全保管。通常是由随机算法生成的，说白了，就是一个巨大的随机整数，256位、32字节。大小介于`1 ~ 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141`之间的数，都可以认为是一个合法的私钥。于是，除了随机方法外，采用特定算法由固定的输入，得到32字节输出的算法就可以成为得到私钥的方法。于是，便有了迷你私钥(Mini Privkey)，原理很简单，例如，采用SHA256的一种实现：

    private key = SHA256(<passphase>)

迷你私钥存在安全问题，因为输入集合太小，易被构造常见组合的彩虹表暴力破解，所以通常还是使用系统随机生成的比较好，无安全隐患。

##### 公钥

公钥与私钥是相对应的，一把私钥可以推出唯一的公钥，但公钥却无法推导出私钥。公钥有两种形式：压缩与非压缩。

早期比特币均使用非压缩公钥，现大部分客户端已默认使用压缩公钥。这个貌似是比特币系统一个长得像feature的bug，早期人少活多代码写得不够精细，openssl库的文档又不足够好，导致Satoshi以为必须使用非压缩的完整公钥，后来大家发现其实公钥的左右两个32字节是有关联的，左侧(X)可以推出右侧(Y)的平方值，有左侧(X)就可以了。

现在系统里两种方式共存，应该会一直共存下去。两种公钥的首个字节为标识位，压缩为33字节，非压缩为65字节。以0x04开头为非压缩，0x02/0x03开头为压缩公钥，0x02/0x03的选取由右侧Y开方后的奇偶决定。

压缩形式可以减小Tx/Block的体积，每个Tx Input减少32字节。

##### 签名
使用私钥对数据进行签署(Sign)会得到签名(Signature)。通常会将数据先生成Hash值，然后对此Hash值进行签名。签名(signature)有两部分组成: R + S。由签名(signature)与Hash值，便可以推出一个公钥，验证此公钥，便可知道此签名是否由公钥对应的私钥签名。

通常，每个签名会有三个长度：73、72、71，符合校验的概率为25%、50%、25%。所以每次签署后，需要找出符合校验的签名长度，再提供给验证方。


##### 地址
地址是为了人们交换方便而弄出来的一个方案，因为公钥太长了(130字符串或66字符串)。地址长度为25字节，转为base58编码后，为34或35个字符。base58是类似base64的编码，但去掉了易引起视觉混淆的字符，又在地址末尾添加了4个字节校验位，保障在人们交换个别字符错误时，也能够因地址校验失败而制止了误操作。

由于存在公钥有两种形式，那么一个公钥便对应两个地址。这两个地址都可由同一私钥签署交易。

公钥生成地址的算法：

```
Version = 1 byte of 0 (zero); on the test network, this is 1 byte of 111
Key hash = Version concatenated with RIPEMD-160(SHA-256(public key))
Checksum = 1st 4 bytes of SHA-256(SHA-256(Key hash))
Bitcoin Address = Base58Encode(Key hash concatenated with Checksum)
```

下图是非压缩公钥生成地址的过程：

![pubkeytoaddr](https://f.cloud.github.com/assets/514951/880381/6290a5ea-f93a-11e2-9ac4-835e86a38642.png)

对于压缩公钥生成地址时，则只取公钥的X部分即可。

##### 推导关系

三者推导关系：私钥 >> 公钥 >> 两个地址。过程均不可逆。拥有私钥便拥有一切，但通常为了方便，会把对应的公钥、地址也存储起来。


#### 交易

比特币的交易(Transation，缩写Tx)，并不是通常意义的交易，例如一手交钱一手交货，而是转账。交易由N个输入和M个输出两部分组成。交易的每个输入便是前向交易的某个输出，那么追踪到源头，必然出现一个没有输入的交易，此类交易称为CoinBase Tx。CoinBase类交易是奖励挖矿者而产生的交易，该交易总是位于Block块的第一笔。

![qq20130727-18](https://f.cloud.github.com/assets/514951/864163/7c9c862e-f61b-11e2-9dfe-324d025e5dd3.png)

拥有一个输入与输出的Tx数据：

    Input:
    Previous tx: f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b009ca73dd04470b9a6
    Index: 0
    scriptSig: 304502206e21798a42fae0e854281abd38bacd1aeed3ee3738d9e1446618c4571d10
    90db022100e2ac980643b0b82c0e88ffdfec6b64e3e6ba35e7ba5fdd7d5d6cc8d25c6b241501

    Output:
    Value: 5000000000
    scriptPubKey: OP_DUP OP_HASH160 404371705fa9bd789a2fcd52d2c580b65d35549d
    OP_EQUALVERIFY OP_CHECKSIG

一旦某个Tx的第N个输出成为另一个Tx的输入，那么该笔比特币即为已花费。每个交易有唯一Hash字符串来标识，通过对交易数据做两次SHA256哈希运算而来：

    Tx Hash ID = SHA256(SHA256(Tx Data))

#### 矿工费

矿工费（Transaction Fee）是鼓励矿工将Tx打包进Block的激励报酬。计算一笔交易的矿工费：

    Transaction Fee = SUM(Input's amount) - SUM(Output's amount)

每笔Tx的矿工费必然大于等于零，否则该笔Tx即为非法，不会被网络接收。

#### 数据块

数据块(Block)是存储Block Meta与Tx的地方。Block的第一笔Tx总是CoinBase Tx，因此Block中的交易数量总是大于等于1，随后是这段时间内网络广播出来的Tx。

找到合适的Block是一件非常困难的事情，需要通过大量的数学计算才能发现，该计算过程称为“挖矿”。首个发现者，会得到一些比特币作为奖励。

#### 数据链

多个Block连接起来成为数据链(Block Chain)。

![blockchain](https://f.cloud.github.com/assets/514951/864443/94b6ba76-f621-11e2-95b0-febc373535b7.png)

为了引入容错与竞争机制，比特币系统允许Block Chain出现分叉，但每个节点总是倾向于选择最高的、难度最大的链，并称之为Best Chain，节点只认可Best Chain上的数据。

首个Block称为Genesis Block，并设定高度为零，后续每新增一个Block，高度则递增一。目前是不允许花费Genesis Block中的比特币的。

* 每个Block中的Tx在此Block中均唯一
* 一个Tx通常只会在一个Block里，也可能会出现在多个Block中，但只会在Best Chain中的某一个Block出现一次

#### 货币存储

比特币是密码货币、纯数字化货币，没有看得见摸得着的硬币或纸币。一个人持有比特币意味着：

1. 其拥有一些地址的私钥
2. 这些地址是数笔交易的输出，且未花费

所有货币记录均以交易形式存储在整个blockchain数据块中，`无交易无货币`。货币不会凭空产生，也不会凭空消失。遗失了某个地址的私钥，意味着该地址上的Tx无法签署，无法成为下一个Tx的输入，便认为该笔比特币永久消失了。

#### 货币发行

既然所有交易的输入源头都是来自CoinBase，产生CoinBase时即意味着货币发行。比特币采用衰减发行，每四年产量减半，第一个四年每个block的coinbase奖励50BTC，随后是25btc, 12.5btc, ...并最终于2140年为零，此时总量达到极限为2100万个btc。

![total_bitcoins_over_time_graph](https://f.cloud.github.com/assets/514951/864426/153fcb3e-f621-11e2-8322-0b2f2f425ef7.png)

减半周期，严格来说，并不是准确的四年，而是每生成210000个block。之所以俗称四年减半，是因为比特币系统会根据全网算力的大小自动调整难度系统，使得大约每两周产生2016个block，那么四年约21万块block。

该函数`GetBlockValue()`用于计算挖得Block的奖励值：

{% codeblock lang:cpp %}
int64 static GetBlockValue(int nHeight, int64 nFees)
{                            
    int64 nSubsidy = 50 * COIN;     
                             
    // Subsidy is cut in half every 210000 blocks, which will occur approximately every 4 years
    nSubsidy >>= (nHeight / 210000);
                             
    return nSubsidy + nFees; 
}
{% endcodeblock %}

当达到2100万btc以后，不再有来自CoinBase的奖励了，矿工的收入来源仅剩下交易的矿工费。此时，每个block的收入绝对值btc很低，但此时比特币应当会非常繁荣，币值也会相当的高，使得矿工们依然有利可图。

#### 杜绝多重支付

传统货币存在多重支付(Double Spending)问题，典型的比如非数字时代的支票诈骗、数字时代的信用卡诈骗等。在比特币系统里，每笔交易的确认均需要得到全网广播，并收录进Block后才能得到真正确认。每笔钱的花销，均需要检测上次输入交易的状态。数据是带时间戳的、公开的，BlockChain由巨大的算力保障其安全性。所以比特币系统将货币的多重支付的风险极大降低，几近于零。通过等待多个Block确认，更是从概率上降低至零。一般得到6个确认后，可认为非常安全。但对于能影响你人生的重大支付，建议等待20~30个确认。

#### 匿名性

任何人均可以轻易生成大量的私钥、公钥、地址。地址本身是匿名的，通过多个地址交易可进一步提高匿名性。但该匿名性并不像媒体宣传的那样，是某种程度上的匿名。因为比特币的交易数据是公开的，所以任何一笔资金的流向均是可以追踪的。

不了解比特币的人为它的匿名性产生一些担忧，比如担心更利于从事非法业务；了解比特币的人却因为它的伪匿名性而苦恼。传统货币在消费中也是匿名的，且是法律保障的，大部分国家都不允许个人涂画纸币。

地址本身是匿名的，但你可以通过地址对应的私钥签名消息来向公众证明你拥有某个比特币地址。

### 其他名词

#### 哈希

哈希(Hash)是一种函数，将一个数映射到另一个集合当中。不同的哈希函数映射的空间不同，反映到计算机上就是生成的值长度不一样。同一个哈希函数，相同的输入必然是相同的输出，但同一个输出却可能有不同的输入，这种情况称为哈希碰撞。

常见的哈希函数有`CRC32`, `MD5`, `SHA1`, `SHA-256`, `SHA-512`, `RIPEMD-160`等，哈希函数在计算中有着非常广泛的用途。比特币里主要采用的是`SHA-256`和`RIPEMD-160`。

#### 脑钱包&纸钱包

前面提到过的脑钱包与纸钱包，这其实不算是钱包的分类，只是生成、存储密钥的方式而已。脑钱包属于迷你私钥的产物。脑钱包就是记在脑袋里的密钥，纸钱包就是打印到纸上的密钥，仅此而已。

有同学提到过，以一个计算机文件作为输入，例如一个数MB大小的照片，通过某种Hash运算后得到私钥的方法。这个方案的安全性还是不错的，同时可以防止盗私钥木马根据特征扫描私钥。文本形式存储私钥是有特征的，而一个照片文件却难以察觉，即使放在云盘等第三方存储空间中都是安全的。